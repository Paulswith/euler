/*
create at `2019-10-12` by `itachy`
*/

pub(super) mod problem_1 {
    /*
    Multiples of 3 and 5
    - Problem 1
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.
    ------------------------------------------------------------------------------------------------
    ** 解:
    [1 - 1000)内的倍数之和, 可以用等差数列的方式的求和方法来处理, 3和5是两个等差数列, 最后Sn_3 + Sn_5
    */
    pub fn entry() {
        let range_max = 1000;
        let multiple_3 = 3;
        let multiple_5 = 5;
        let sum = sum_multiple(multiple_3, range_max) + sum_multiple(multiple_5, range_max);
        assert_eq!(sum, test(multiple_3, multiple_5, range_max));
        println!("sum of all the multiples of 3 or 5 below 1000, result is {}", sum);
    }

    #[warn(dead_code)]
    fn sum_multiple(multiple: u32, in_range_max: u32) -> u32 {
        let n = (in_range_max - 1) / multiple; // - 1, cause [1, 1000)
        let a_1 = 1 * multiple;
        let a_n = n * multiple;
        (a_1 + a_n) / 2 * n   // Sn = ((a1 + an) / 2) * n
    }

    /// use normal way resolved to validate
    #[warn(dead_code)]
    fn test(multiple_first: u32, multiple_second: u32,  in_range_max: u32) -> u32 {
        let mut counter: u32 = 0;
        for i in 1..in_range_max {
            if i % multiple_first == 0 {
                counter += i;
            }
            if i % multiple_second == 0 {
                counter += i;
            }
        }
        counter
    }
}

pub(super) mod problem_2 {
    /*
    Even Fibonacci numbers
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

    ** 解:
    观察了一下数据, 从2开始, 每间隔3就是偶数.
    */
    pub fn entry() {
        let fibonacci_sequence_within_four_million= generate_fibonacci_sequence();
        println!("problem 2, data source: {:?}", fibonacci_sequence_within_four_million);
        let mut sum = 0;
        fibonacci_sequence_within_four_million.iter().for_each(|fibonacci| {
            if fibonacci % 2 == 0 { sum += fibonacci.clone(); }
        });
        assert_eq!(sum_even_number_of_fibonacci_sequence(&fibonacci_sequence_within_four_million), sum);
        println!("Sum even-value of fibonacci sequence within four million is {}", sum);
    }

    #[warn(dead_code)]
    fn sum_even_number_of_fibonacci_sequence(fibonacci_sequence: &Vec<u32>) -> u32 {
        let len = fibonacci_sequence.len();
        let mut sum: u32 = 0;
        let mut pace = 2 - 1; // the second one, convert to collection index is 1
        loop {
            if pace > len { break }
            sum += fibonacci_sequence[pace];
            pace += 3;
        }
        sum
    }

    fn generate_fibonacci_sequence() -> Vec<u32> {
        let four_million: u32 = 4_000_000;
        let mut container: Vec<u32> = vec![1, 2, 3];
        // indicate [any_item. previous_second, previous_first]
        let previous_first= |tc: &Vec<u32>| tc[tc.len() - 1];
        let previous_second= |tc: &Vec<u32>| tc[tc.len() - 2];
        loop {
            let previous_first = previous_first(&container);
            let previous_second = previous_second(&container);
//            println!("previous {}, {}", previous_first, previous_second);
            let append_item: u32 = previous_first + previous_second;
            if append_item > four_million { break }
            container.push(append_item);
        }
        container
    }
}